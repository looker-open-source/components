"use strict";(globalThis.webpackChunk_looker_storybook=globalThis.webpackChunk_looker_storybook||[]).push([[9700],{"../filter-expressions/src/utils/date/date_conversions.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{E4:()=>addDays,Ly:()=>filterDateTimeModelToDate,Q5:()=>clearTimeFilterDateTimeModel,Y8:()=>hasTimeFilterDateTimeModel,uz:()=>dateToFilterDateTimeModel});const dateToFilterDateTimeModel=(date=new Date)=>({year:date.getFullYear(),month:date.getMonth()+1,day:date.getDate(),hour:date.getHours(),minute:date.getMinutes(),second:date.getSeconds()}),filterDateTimeModelToDate=({year,month,day,hour=0,minute=0,second=0})=>new Date(year,month-1,day,hour,minute,second),addDays=(date,days)=>{const result=new Date(date);return result.setDate(result.getDate()+days),result},clearTimeFilterDateTimeModel=model=>({year:model.year,month:model.month,day:model.day}),hasTimeFilterDateTimeModel=model=>void 0!==model&&void 0!==model.hour&&void 0!==model.minute&&void 0!==model.second},"../filter-expressions/src/utils/date/get_months.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{w:()=>getMonths});var i18next__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/i18next/dist/esm/i18next.js");const getMonths=translate=>{const t=translate||i18next__WEBPACK_IMPORTED_MODULE_0__.Z.t.bind(i18next__WEBPACK_IMPORTED_MODULE_0__.Z);return[t("January",{ns:"get_months"}),t("February",{ns:"get_months"}),t("March",{ns:"get_months"}),t("April",{ns:"get_months"}),t("May",{ns:"get_months"}),t("June",{ns:"get_months"}),t("July",{ns:"get_months"}),t("August",{ns:"get_months"}),t("September",{ns:"get_months"}),t("October",{ns:"get_months"}),t("November",{ns:"get_months"}),t("December",{ns:"get_months"})]}},"../filter-expressions/src/utils/date/is_date_time.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{v:()=>isDateTime});const isDateTime=filterType=>"date_time"===filterType},"../filter-expressions/src/utils/transform/utils/apply_id_to_ast.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});const __WEBPACK_DEFAULT_EXPORT__=root=>{let id=0;const traverse=node=>{const{left,right}=node;let newLeft,newRight;left&&(newLeft=traverse(left)),id+=1;const newNode={...node,id};return right&&(newRight=traverse(right)),{...newNode,left:newLeft,right:newRight}};return traverse(root)}},"../filter-expressions/src/utils/tree/inorder_traversal.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{G:()=>inorderTraversal});const inorderTraversal=(root,nodeHandler)=>{const inorder=(node,parent)=>{node&&(inorder(node.left,node),nodeHandler(node,parent),inorder(node.right,node))};inorder(root,null)}},"../filter-expressions/src/utils/tree/remove_node.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>removeNode});var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/lodash/cloneDeep.js"),lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);const removeNode=(root,nodeId)=>{const workingRoot=lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(root);if(workingRoot.id===nodeId)return;if(workingRoot.left&&workingRoot.left.id===nodeId)return workingRoot.right;if(workingRoot.right&&workingRoot.right.id===nodeId)return workingRoot.left;let parent=workingRoot,pointer=workingRoot.right;for(;pointer;){if(pointer.left&&pointer.left.id===nodeId)return parent.right=parent.right?parent.right.right:void 0,workingRoot;if(pointer.right&&pointer.right.id===nodeId)return parent.right=parent.right?parent.right.left:void 0,workingRoot;parent=pointer,pointer=pointer.right}return workingRoot}},"../filter-expressions/src/utils/tree/tree_to_list.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{i:()=>treeToList});var _inorder_traversal__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../filter-expressions/src/utils/tree/inorder_traversal.ts");const treeToList=root=>{const orItems=[],andItems=[];return(0,_inorder_traversal__WEBPACK_IMPORTED_MODULE_0__.G)(root,(node=>{const item=node;","!==item.type&&(item.is?orItems:andItems).push(item)})),[...orItems,...andItems]}},"../filter-expressions/src/utils/type_to_grammar.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>typeToGrammar});const initializer="\n{\n  const Object = options.Object;\n  const getNumberFromString = options.getNumberFromString;\n}\n",numbers='\n/* Common numbers parsing expressions */\n\nnumber "number"\n = (minus? int frac? exp?) { return getNumberFromString(text()); } / (minus? int? frac exp?) { return getNumberFromString(text()); } \n\npositive "positive"\n = int frac? exp? { return getNumberFromString(text()); }\n\npositiveInteger "positive integer"\n= int { return getNumberFromString(text()); }\n\ninteger "integer"\n = minus? int { return getNumberFromString(text()); }\n\nnot = "not"i\ndecimal_point = "."\ndigit1_9      = [1-9]\ne             = [eE]\nexp           = e (minus / plus)? DIGIT+\nfrac          = decimal_point DIGIT+\nint           = zero / (digit1_9 DIGIT*)\nminus         = "-"\nplus          = "+"\nzero          = "0"\nDIGIT  = [0-9]\n',whitespace='\n_ "whitespace"\n  = SPACE*\n\nSPACE "space"\n  = [ \\t\\n\\r]+\n',userAttribute='\n//LOOKER USER_ATTRIBUTE GRAMMAR\n//MATCHES {{ _user_attributes[\'id\'] }}\n\nUSER_ATTRIBUTE = UA_START _ attributeName:ATTRIBUTE _ UA_END {\n  return {type:\'user_attribute\', attributeName: attributeName, is: true}\n}\n\nUA_START = "{{" _ "_user_attributes["\n\nUA_END = "]" _ "}}"\n\nUA_SINGLE_QUOTE = "\'"\n\nUA_DOUBLE_QUOTE = "\\""\n\nATTRIBUTE = UA_SINGLE_QUOTE word:UA_WORD UA_SINGLE_QUOTE {\n  return word\n} / UA_DOUBLE_QUOTE word:UA_WORD  UA_DOUBLE_QUOTE {\n  return word\n}\n\nUA_WORD = chars:UA_CHARS+ {\n\treturn chars.join("")\n    }\n\nUA_CHARS = [A-Za-z0-9_]\n\n',dateGrammar=[initializer,'\n\n//LOOKER DATE GRAMMAR\nROOT = EXPRESSION\n\nEXPRESSION = expression:( LOGICAL_EXPRESSION / TERM ) {\n\treturn Object.assign({}, expression, {is:true})\n}\n\nLOGICAL_EXPRESSION = left:TERM _ type:LOGIC_SYMBOL _ right:EXPRESSION {\n\treturn {\n    \ttype:type.toLowerCase(),\n        left: left,\n        right: right,\n        is: true\n    }\n}\n\nTERM = term:(USER_ATTRIBUTE /\n       DATES /\n       RELATIVE_RANGE /\n       FROM_NOW /\n       PAST_AGO /\n       PAST /\n       THIS_RANGE / \n       THIS_NEXT /\n       LAST /\n       LAST_INTERVAL /\n       DAY_INTERVAL /\n       BEFORE_AFTER_THIS_NEXT_LAST /\n       DAY_EXPRESSIONS /\n       BEFORE_AFTER /\n       FISCAL_QUARTER_RULE /\n       FISCAL_YEAR_RULE /\n       NULLS) {\n           return Object.assign({}, term, {is: true})\n       }\n\nTHIS_NEXT = type:("this"i / "next"i) _ unit:DAY_YEAR_UNITS {\n\treturn {type:type.toLowerCase(), unit:unit}\n}\n\nLAST = type:("last"i) _ unit:INTERVAL_UNIT {\n\treturn {type:type.toLowerCase(), unit:unit}\n}\n\nTHIS_RANGE = "THIS "i startInterval:INTERVAL_UNIT " TO "i endInterval:INTERVAL_UNIT {\n    return {\n        type: \'thisRange\',\n        startInterval: startInterval,\n        endInterval: endInterval\n    }\n}\n\nPAST = interval:N_INTERVAL {\n\treturn {type:\'past\', value:interval.value, unit:interval.unit}\n}\n\nPAST_AGO = interval:N_INTERVAL SPACE "AGO"i {\n\treturn {type:\'pastAgo\', value:interval.value, unit:interval.unit}\n}\n\nLAST_INTERVAL = "last"i _ interval:N_INTERVAL {\n\treturn {type:\'lastInterval\', value:interval.value, unit:interval.unit}\n}\n\nFROM_NOW = interval:N_INTERVAL SPACE "FROM NOW"i {\n\treturn {type:\'from now\', value:interval.value, unit:interval.unit}\n}\n\nINTERVAL_TYPE = SPACE dir:("AGO"i/"FROM NOW"i) {\n\treturn dir.toLowerCase() === "ago" ? "ago" : "from now"\n}\n\nRELATIVE_RANGE = startInterval:N_INTERVAL intervalType:INTERVAL_TYPE SPACE "for"i SPACE endInterval:N_INTERVAL  {\n    if (startInterval.value === endInterval.value &&\n        startInterval.unit === endInterval.unit) {\n        return {\n            type: \'past\',\n            value: startInterval.value,\n            unit: startInterval.unit,\n            complete: true\n        }\n    }\n    return {type:\'relative\', intervalType:intervalType, startInterval:startInterval, endInterval:endInterval}\n\n}\n\nBEFORE_AFTER = prefix:(BEFORE / AFTER) SPACE interval:N_INTERVAL intervalType:INTERVAL_TYPE? {\n    return {\n        range: \'relative\',\n        value: interval.value,\n        unit: interval.unit,\n        type: prefix,\n        fromnow: intervalType === \'from now\'\n    }\n} / prefix:(BEFORE / AFTER) SPACE date:DATETIME {\n    return { range: \'absolute\', date: date, type: prefix}\n}\n\nBEFORE_AFTER_THIS_NEXT_LAST = prefix:(BEFORE / AFTER) _ type:("this"i / "next"i / "last"i) _ unit:DAY_YEAR_UNITS  {\n    return {\n        type:prefix.toLowerCase() + \'_\' + type,\n        unit: unit\n    }\n}\nRANGE = start:DATETIME SPACE "TO"i SPACE end:DATETIME {\n\t\treturn {\n        \ttype:\'range\',\n            start:start,\n            end:end\n        }\n    }\n\nRANGE_INTERVAL = start:DATETIME SPACE "FOR"i SPACE end:N_INTERVAL {\n\t\treturn {\n        \ttype:\'rangeInterval\',\n            start:start,\n            end:end\n        }\n    }\n\nYEAR_MONTH_INTERVAL = start:YEAR_MONTH_RULE SPACE "FOR"i SPACE end:N_INTERVAL {\n    return {\n        type:\'monthInterval\',\n        year: start.year,\n        month: start.month,\n        end:end\n    }\n}\n\nDAY_EXPRESSIONS = day:(DAY_OF_WEEK_KEYWORD / DAY_KEYWORD) {\n      return {type:\'day\', day:day}\n  }\n\nDAY_INTERVAL = day:(DAY_EXPRESSIONS) _ "for"i _ interval:N_INTERVAL {\n    return {type:\'dayInterval\',value:interval.value, unit:interval.unit}\n}\n\nN_INTERVAL = value:positiveInteger SPACE unit:INTERVAL_UNIT {\n\t\treturn {type: \'interval\', value:value, unit:unit}\n\t}\n\nDATES = RANGE_INTERVAL /\n        RANGE /\n        DATETIME_RULE /\n        YEAR_MONTH_INTERVAL /\n        YEAR_QUARTER_RULE /\n        YEAR_MONTH_RULE /\n        YEAR_RULE\n\nYEAR_RULE = year:YYYY {\n\treturn {type:\'year\', year:year}\n   }\n\nFISCAL_YEAR_RULE = "FY" year:YYYY {\n\treturn {type:\'fiscalYear\', year:year}\n   }\n\nFISCAL_QUARTER_RULE = fy:FISCAL_YEAR_RULE "-" quarter:("Q1"/"Q2"/"Q3"/"Q4") {\n\treturn {type:\'fiscalQuarter\', year:fy.year, quarter:quarter}\n   }\n\nYEAR_MONTH_RULE = year:YYYY DATE_SEPARATOR month:MM {\n    return {\n        type: \'month\',\n        year:year,\n        month:month\n    }\n}\n\nYEAR_QUARTER_RULE = year:YYYY quarter:QUARTER_RULE {\n    return {\n        type: \'quarter\',\n        year:year,\n        quarter:quarter\n    }\n}\n\nNULLS = "NULL"i {\n\t\treturn {type:\'null\'}\n\t} / "NOT NULL"i {\n    \treturn {type: \'notnull\'}\n    }\n\n// next month\nTHISNEXT = type:(THIS/NEXT) " " interval:INTERVAL_UNIT {\n\treturn {\n    \ttype: type.toLowerCase(),\n        interval: interval.toLowerCase()\n    }\n}\n\n// FY2018\nFY = type:"fy"i fy:YYYY quarter:QUARTER_RULE ?{\n\t\treturn Object.assign({}, {type:\'datetime\', fy:fy}, quarter)\n    }\n\nQUARTER_RULE = DATE_SEPARATOR "Q"i quarter:[1-4] {\n\treturn {quarter:quarter}\n}\n\nDAY_KEYWORD = day:("today"i / "yesterday"i / "tomorrow"i) { return day.toLowerCase()}\n\nDAY_OF_WEEK_KEYWORD = day:("monday"i / "tuesday"i / "wednesday"i / "thursday"i / "friday"i / "saturday"i / "sunday"i){ return day.toLowerCase()}\n\nINTERVAL_UNIT = TIME_UNITS / DAY_YEAR_UNITS\n\n// break units as used by the this/next/last expressions\nTIME_UNITS = keyword:$(\n           SECOND /\n           MINUTE /\n           HOUR) ("s"i)? {\n             return keyword.toLowerCase()\n           }\n// units used by \nDAY_YEAR_UNITS = keyword:$(\n           DAY /\n           WEEK /\n           MONTH /\n           QUARTER/\n           FISCAL_QUARTER /\n           YEAR /\n           FISCAL_YEAR) ("s"i)? {\n             return keyword.toLowerCase()\n           }\n\n\n// 2019/01/01 08:45:00\nDATETIME_RULE = datetime: DATETIME {\n    return {\n        type: \'on\',\n        date: datetime\n    }\n}\n\nDATETIME = date:DATE time:(TIME)? {\n\tlet result = Object.assign({}, date, time)\n    return result\n}\n\nDATE = year:YYYY mm_rule:MM_RULE {\n  return Object.assign({}, { year: year || \'\' }, mm_rule)\n}\n\nMM_RULE = DATE_SEPARATOR month:MM dd_rule:DD_RULE {\n\treturn Object.assign({}, { month: month || \'\' }, dd_rule)\n}\n\nDD_RULE = DATE_SEPARATOR day:DD { return {day:day} }\n\nTIME = SPACE hour:hh TIME_SEPARATOR minute:mm second:ss? {\n  let result = {hour: hour, minute: minute, second: second || \'\'}\n  return result\n}\n\nss = TIME_SEPARATOR second: mm {\n\treturn second\n}\n\nDATE_SEPARATOR = ("/" / "-")\nTIME_SEPARATOR = ":"\n\nLOGIC_SYMBOL = ","\n\nTHIS = "this"i\nNEXT = "next"i\n\nSECOND = "second"i\nMINUTE = "minute"i\nHOUR = "hour"i\nDAY = "day"i\nWEEK ="week"i\nMONTH = "month"i\nQUARTER = "quarter"i\nFISCAL_QUARTER = "fiscal quarter"i\nYEAR = "year"i\nFISCAL_YEAR = "fiscal year"i\n\nBEFORE = "before"i {return \'before\'}\nAFTER = "after"i {return \'after\'}\n\nDD = value:([0][1-9]/[1][0-9]/[2][0-9]/[3][0-1]) {return value.join(\'\')}\nMM = value:([0][1-9]/[1][0-2]) {return value.join(\'\')}\nYYYY = value:([0-9][0-9][0-9][0-9]) {return value.join(\'\')}\n\nhh = value:([0][0-9]/[1][0-9]/[2][0-3]) {return value.join(\'\')}\nmm = value:([0][0-9]/[1][0-9]/[2][0-9]/[3][0-9]/[4][0-9]/[5][0-9]) {return value.join(\'\')}\n',numbers,whitespace,userAttribute].join(""),numberGrammar=[initializer,'\n\nEXPRESSION\n= LOGICAL_EXPRESSION / TERM\n\nLOGICAL_EXPRESSION\n= left:TERM _ type:LOGIC_SYMBOL _ right:EXPRESSION {\n  return {\n     type: type.toLowerCase(),\n       left:left,\n       right:right\n   }\n}\n\nTERM\n= USER_ATTRIBUTE / not:(NOT_SYMBOL SPACE)? term:(NULLS / COMP_INTERVALS / COMPARISON / TO / VALUE) {\n  const is = not ? false : true\n  return Object.assign({is:is}, term)\n} / not:(NOT_SYMBOL)?  SPACE? term:(INTERVAL) {\n  term.is = not ? false : true\n  return term\n}\n\nVALUE\n= value:number {\n  return {\n     type: \'=\',\n     value: [value]\n   }\n}\n\nCOMP_INTERVALS = INTERVAL_COMP1 / INTERVAL_COMP2 / INTERVAL_COMP3 / INTERVAL_COMP4\n\n/* Special rules for defining BETWEEN ranges using comparison operators with AND/OR */\n\n/* >= 7 AND <80.44 becomes (7, 80.44) */\nINTERVAL_COMP1 = ">" first:"="? _ n1:number _ "AND"i _ "<" second:"="? n2:number {\n  const open = first ? "[" : "("\n  const close = second ? "]" : ")"\n  return {\n    type: \'between\',\n    bounds: open + close,\n    first: first,\n    second: second,\n    low: n1,\n    high: n2\n  }\n}\n\n/* <=80.44  AND    >.1  becomes (0.01, 80.44] */\nINTERVAL_COMP2 = "<" first:"="? _ n1:number _ "AND"i _ ">" second:"="? n2:number {\n  //const open = ["(", "["][first.length-1]\n  //const close = [")", "]"][second.length-1]\n  const open = second ? "[" : "("\n  const close = first ? "]" : ")"\n  return {\n    type: \'between\',\n    bounds: open + close,\n    low: n2,\n    high: n1\n  }\n}\n\n/* <= 7 OR >80.44 becomes [7, 80.44) */\nINTERVAL_COMP3 = "<" first:"="?_ n1:number _ "OR"i _ ">" second:"="? n2:number {\n  const open = first ? "[" : "("\n  const close = second ? "]" : ")"\n  return {\n    type: \'between\',\n    bounds: open + close,\n    low: n1,\n    high: n2,\n    is: false\n  }\n}\n\n/* >=80.44 OR <.1 becomes (0.01, 80.44]*/\nINTERVAL_COMP4 = ">" first:"="? _ n1:number _ "OR"i _ "<" second:"="? n2:number {\n  const open = second ? "[" : "("\n  const close = first ? "]" : ")"\n  return {\n    type: \'between\',\n    bounds: open + close,\n    low: n2,\n    high: n1,\n    is: false\n  }\n}\n\nINTERVAL\n= open:OPEN _ left:(number) _ COMMA _ right:(number) _ close:CLOSE {\n  return {\n    type: \'between\',\n      bounds: open + close,\n      low: left,\n      high: right\n  }\n} / open:OPEN _ left:(number) _ COMMA _  close:CLOSE {\n      const type = open == \'(\' ? \'>\' : \'>=\'\n      const value = [left]\n      return {type:type, value:value}\n} /  open:OPEN _  COMMA _ right:(number) _ close:CLOSE {\n      const type = close == \')\' ? \'<\' : \'<=\'\n      const value = [right]\n      return {type:type, value:value}\n } / "(" _ "-inf" _ COMMA _ right:(number) _ close:CLOSE {\n      const type = close == \')\' ? \'<\' : \'<=\'\n      const value = [right]\n      return {type:type, value:value}\n } / open:OPEN _ left:(number) _ COMMA _ "inf" _ ")" {\n      const type = open == \'(\' ? \'>\' : \'>=\'\n      const value = [left]\n      return {type:type, value:value}\n }\n\nTO\n  =  begin:$(number)? _ "to"i _ end:$(number)? _ {\n    if(begin && end) {\n       return {\n           type: \'between\',\n           bounds: \'[]\',\n           low: begin,\n           high: end\n       }\n    }\n\n     if(begin) {\n       return {\n          type: \'>=\',\n          value: [begin.trim()]\n       }\n     }\n\n     if(end) {\n       return {\n          type: \'<=\',\n          value: [end.trim()]\n       }\n     }\n     expected(\'number before or after to\')\n  }\n\n\nCOMPARISON\n = symbol:COMP_SYMBOL _ value:number {\n   return {\n      type: symbol,\n      value: [value]\n   }\n }\n\nNULLS\n = type:("NULL"i) {\n     return  {\n       type: type.toLowerCase()\n     }\n   }\n\n/* SYMBOLS */\nLOGIC_SYMBOL = COMMA / OR { return "," }\nOR = "OR"i\nAND = "AND"i\nCOMMA = ","\nOPEN = "(" / "["\nCLOSE = ")" / "]"\nNOT_SYMBOL = "NOT"i / "!=" / "<>" { return \'not\' }\nCOMP_SYMBOL = ( COMP_G / COMP_L )\nCOMP_G = (GTE / GT)\nGTE = ">="\nGT = ">"\nCOMP_L = (LTE / LT)\nLTE = "<="\nLT = "<"\n',userAttribute,numbers,whitespace].join(""),stringGrammar='ROOT\n= EXPRESSION / EMPTY_STRING\n\nEMPTY_STRING = \'\' {\n    return {\n      type: \'match\',\n      value: [],\n      is: true\n    }\n  }\n\nEXPRESSION\n= LIST / TERM\n\nLIST\n= left:TERM COMMA right:EXPRESSION {\n return {\n     type: \',\',\n       left: left,\n       right: right\n   }\n}\n\nTERM\n= USER_ATTRIBUTE / not:(NOT)? term:(PCT / KEYWORDS / MATCH) {\n    term.is = not ? false : true\n    return term\n   }\n\nKEYWORDS = ("EMPTY" / "empty") {\n       return {\n           type: \'blank\',\n       }\n   }\n   / ("NULL" / "null") {\n       return {\n           type: \'null\',\n       }\n   }\n\nMATCH\n   = quotation_mark sequence:(char / PCT_SYMBOL / COMMA / UNDERSCORE / CARET)+ quotation_mark {\n          return {\n              type:\'match\',\n              value: [sequence.join(\'\')]\n          }\n      }\n      / sequence:raw_string {\n       return {\n           type:\'match\',\n           value: [sequence]\n       }\n   }\n\nPCT\n=  CONTAINS / STARTS_WITH / ENDS_WITH / OTHER\n\nCONTAINS\n = PCT_SYMBOL value:string PCT_SYMBOL !(string / PCT_SYMBOL / UNDERSCORE)  {\n     return {\n         type: \'contains\',\n         value: [value]\n       }\n   }\n\nSTARTS_WITH\n  = value:string PCT_SYMBOL !(string / PCT_SYMBOL / UNDERSCORE) {\n \t\treturn {\n         type: \'startsWith\',\n         value: [value]\n     }\n }\n\nENDS_WITH\n  =  PCT_SYMBOL value:string !(PCT_SYMBOL / UNDERSCORE) {\n return {\n        type: \'endsWith\',\n        value: [value]\n    }\n}\n\nOTHER = value: $(string* (PCT_SYMBOL / UNDERSCORE) string*)+ {\n\treturn {\n    \ttype: \'other\',\n        value: [value]\n    }\n}\n\nNOT = \'-\'\n\nCOMMA = COMMA_SYMBOL\n\nraw_string "string"\n = str:char_sequence { return str }\n\nstring "string"\n = str:char_sequence { return str ? str.trim():str}\n/* ----- 7. Strings ----- */\n\nchar_sequence "string"\n = quotation_mark chars:(valid_char / escaped_quotation_mark)* quotation_mark {\n     return \'"\' + chars.join("") + \'"\'\n   }\n   /\n   chars:char+ {return chars.join(\'\') }\n\nchar "character"\n =  ESCAPE_CARET\n / escape symbol:SYMBOLS { return symbol}\n / escape\n   sequence:(\n         \'"\'\n     / "\\\\"\n     / "/"\n     / "b" { return "\\b"; }\n     / "f" { return "\\f"; }\n     / "n" { return "\\n"; }\n     / "r" { return "\\r"; }\n     / "t" { return "\\t"; }\n     / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {\n         return String.fromCharCode(parseInt(digits, 16));\n       }\n   )\n   { return sequence }\n\n   / unescaped\n   / NOT_SYMBOL\n\n/* Returns a single space for double escaped space at the end, or before a comma\nto reverse escapeWithDoubleLastEscape */\nESCAPE_CARET\n = CARET (SPACE_SYMBOL ! FOLLOWING_SPACE_END / ESCAPED_DOUBLE_SPACE) {\n     return " "\n   }\n   /\n   CARET symbol:(PCT_SYMBOL / UNDERSCORE / COMMA_SYMBOL / CARET / NOT_SYMBOL) {\n     return symbol\n   }\n\nSYMBOLS = PCT_SYMBOL / COMMA_SYMBOL / NOT_SYMBOL / UNDERSCORE / CARET\nPCT_SYMBOL \t\t        = \'%\'\nUNDERSCORE \t\t        = \'_\'\nCOMMA_SYMBOL   \t        = ","\nNOT_SYMBOL\t  \t        = "-"\nSPACE_SYMBOL            = " "\nFOLLOWING_SPACE_END     = "^ " (&COMMA_SYMBOL / !.)\nESCAPED_DOUBLE_SPACE    = " ^ "\nCARET \t   \t\t        = "^"\nescape         \t        = "\\\\"\nescaped_quotation_mark  = \'\\\\"\'\nquotation_mark \t        = \'"\'\nunescaped      \t        = !SYMBOLS char:char_range { return char;}\nvalid_char              = char:char_range { return char;}\nchar_range              = [^\\0-\\x1F\\x22\\x5C]\nHEXDIG                  = [0-9a-f]i\n'.concat(userAttribute,whitespace),tierGrammar="TierExpression\n= USER_ATTRIBUTE / MATCH_LIST / MATCH_TERM\n\nMATCH_LIST\n= left:MATCH_TERM COMMA _ right:TierExpression {\n return {\n     type: ',',\n       left: left,\n       right: right\n   }\n}\n\nMATCH_TERM\n= not:(NOT)? term:(MATCH) {\n term.is = not ? false : true\n return term\n}\n\n".concat(stringGrammar),locationGrammar=[initializer,'EXPRESSION\n= CIRCLE / LOCATION / BOX / USER_ATTRIBUTE / NULLS / ANYWHERE\n\nANYWHERE = \'\' {\n\treturn {type:\'anywhere\'}\n}\n\nNULLS = NULL_RULE / NOTNULL\n\nNULL_RULE = NULL {\n\treturn {type: \'null\'}\n}\n\nNOTNULL = (NOT _ NULL / "-"NULL) {\n\treturn {type: \'notnull\'}\n}\n\nBOX\n= "INSIDE"i _ "BOX"i_ "FROM"i _ from:LOCATION _ "to"i _ to:LOCATION _ {\n\treturn {type:\'box\', lat: from.lat, lon: from.lon, lat1: to.lat, lon1: to.lon}\n}\n\nCIRCLE\n= !MINUS distance:DISTANCE _ unit:UNIT _ "from"i _ location:LOCATION {\n\treturn {type: \'circle\', distance:distance, unit:unit, lat: location.lat, lon: location.lon }\n}\n\nLOCATION = lat:LAT _ COMMA _ lon:LON {\n\treturn { type: \'location\', lat:lat, lon:lon }\n}\n\nDISTANCE = number {\n\tvar value = parseFloat(text())\n\tif(value < 0) {\n\t\texpected(\'a positive value\')\n\t}\n\treturn value\n}\n\nUNIT = (METERS / FEET / KILOMETERS / MILES)\nMETERS = "meters"i\nFEET = "feet"i\nKILOMETERS = "kilometers"i\nMILES = "miles"i\nNULL = "null"i\nNOT = "not"i\nMINUS = "-"\n\nLAT = lat:number {\n\tvar value = parseFloat(text())\n\tif(value < -90 || value > 90) {\n\t\texpected(\'a number between -90 and 90\')\n\t}\n\treturn value\n}\nLON = number {\n\tvar value = parseFloat(text())\n\tif(value < -180 || value > 180) {\n\t\texpected(\'a number between -180 and 180\')\n\t}\n\treturn value\n}\nCOMMA = ","\n',userAttribute,numbers,whitespace].join(""),anyValue={id:1,type:"anyvalue",is:!0},anyStringItem={id:1,type:"match",value:[],is:!0},userAttributeToString=({attributeName})=>attributeName?`{{ _user_attributes['${attributeName}'] }}`:"",is_item_to_string=(is=!0,yes="",no="not ")=>`${is?yes:no}`,null_item_to_string=({is})=>`${is_item_to_string(is)}null`;__webpack_require__("../../node_modules/core-js/modules/esnext.async-iterator.filter.js"),__webpack_require__("../../node_modules/core-js/modules/esnext.iterator.constructor.js"),__webpack_require__("../../node_modules/core-js/modules/esnext.iterator.filter.js"),__webpack_require__("../../node_modules/core-js/modules/esnext.async-iterator.map.js"),__webpack_require__("../../node_modules/core-js/modules/esnext.iterator.map.js");var tree_to_list=__webpack_require__("../filter-expressions/src/utils/tree/tree_to_list.ts");const treeToString=(root,nodeToString,filterNode=(()=>!0))=>(0,tree_to_list.i)(root).filter(filterNode).map(nodeToString).filter(String).join(",");var is_date_time=__webpack_require__("../filter-expressions/src/utils/date/is_date_time.ts"),padStart=__webpack_require__("../../node_modules/lodash/padStart.js"),padStart_default=__webpack_require__.n(padStart);const zeroPad=length=>value=>padStart_default()(String(value),length,"0"),zeroPad2=zeroPad(2),zeroPad4=zeroPad(4);var date_conversions=__webpack_require__("../filter-expressions/src/utils/date/date_conversions.ts");const datetime=(date,showTime)=>{if(!date)return"Invalid Date";const{year,month,day,hour,minute}=date;let result=String(zeroPad4(year));return result+=month?`/${zeroPad2(month)}`:"",result+=day?`/${zeroPad2(day)}`:"",showTime&&(result+=void 0!==hour?` ${zeroPad2(hour)}`:"",result+=void 0!==minute?`:${zeroPad2(minute)}`:""),result},beforeAfter=(item,showTime)=>{const{type,range,date,fromnow,unit}=item;if("absolute"===range)return`${type} ${datetime(date,showTime)}`;const fromNowAgoText=fromnow?"from now":"ago";return"now"===unit?`${type} 0 minutes ${fromNowAgoText}`:`${type} ${intervalToString(item)} ${fromNowAgoText}`},intervalToString=({value,unit})=>`${value} ${unit}`,typeAndUnitToString=({type,unit})=>`${type} ${unit}`,filterToStringMap={null:null_item_to_string,notnull:()=>"not null",past:item=>`${intervalToString(item)}${item.complete?" ago for "+intervalToString(item):""}`,pastAgo:item=>`${intervalToString(item)} ago`,this:typeAndUnitToString,next:typeAndUnitToString,last:typeAndUnitToString,year:({year})=>`${zeroPad4(year)}`,month:({year,month})=>`${zeroPad4(year)}-${zeroPad2(month)}`,day:({day})=>`${day}`,before:beforeAfter,after:beforeAfter,range:({start,end},showTime)=>`${datetime(start,showTime)} to ${datetime(end,showTime)}`,thisRange:({startInterval,endInterval})=>`this ${startInterval} to ${endInterval}`,on:({date},showTime)=>`${datetime(date,showTime&&(0,date_conversions.Y8)(date))}`,relative:({startInterval,intervalType,endInterval})=>`${intervalToString(startInterval)} ${intervalType} for ${intervalToString(endInterval)}`,anyvalue:()=>"",user_attribute:userAttributeToString};var i18next=__webpack_require__("../../node_modules/i18next/dist/esm/i18next.js"),defaultTo=__webpack_require__("../../node_modules/lodash/defaultTo.js"),defaultTo_default=__webpack_require__.n(defaultTo);const describeIsItem=(is,value)=>{const t=i18next.Z.t.bind(i18next.Z),no=t("is not value",{ns:"describe_is_item",value}),yes=t("is value",{ns:"describe_is_item",value});return is?yes:no},describeNull=({is})=>describeIsItem(is,"null"),describeUserAttribute=({attributeValue})=>attributeValue?describeIsItem(!0,attributeValue):"",maxHourValue=hour=>hour<=0||hour>=24?0:hour,maxMinuteValue=minute=>!minute||minute<0||minute>=60?0:minute,getAccurateMeridiem=({hour,meridiem="AM"})=>hour>12?"PM":meridiem.toUpperCase(),meridiemFrom24HourTime=hour=>hour>=12&&hour<24?"PM":"AM",get12HourTimeValue=hour=>(hour>12&&(hour-=12),0===hour&&(hour=12),hour),formatAndDisplayTime=({hour,minute=0,meridiem="AM"})=>(({hour,minute=0,meridiem=""})=>`${hour}:${zeroPad2(minute)} ${meridiem}`.trim())({hour:get12HourTimeValue(maxHourValue(hour)),minute:maxMinuteValue(minute),meridiem:getAccurateMeridiem({hour:maxHourValue(hour),meridiem})});var get_months=__webpack_require__("../filter-expressions/src/utils/date/get_months.ts");const getUnitLabel=(unit,value=1)=>1!==value?(unit=>{const t=i18next.Z.t.bind(i18next.Z);return{"fiscal year":t("fiscal years",{ns:"get_unit_label"}),year:t("years",{ns:"get_unit_label"}),"fiscal quarter":t("fiscal quarters",{ns:"get_unit_label"}),quarter:t("quarters",{ns:"get_unit_label"}),month:t("months",{ns:"get_unit_label"}),week:t("weeks",{ns:"get_unit_label"}),day:t("days",{ns:"get_unit_label"}),hour:t("hours",{ns:"get_unit_label"}),minute:t("minutes",{ns:"get_unit_label"}),second:t("seconds",{ns:"get_unit_label"}),"complete fiscal year":t("complete fiscal years",{ns:"get_unit_label"}),"complete year":t("complete years",{ns:"get_unit_label"}),"complete fiscal quarter":t("complete fiscal quarters",{ns:"get_unit_label"}),"complete quarter":t("complete quarters",{ns:"get_unit_label"}),"complete month":t("complete months",{ns:"get_unit_label"}),"complete week":t("complete weeks",{ns:"get_unit_label"}),"complete day":t("complete days",{ns:"get_unit_label"}),"complete hour":t("complete hours",{ns:"get_unit_label"}),"complete minute":t("complete minutes",{ns:"get_unit_label"}),"complete second":t("complete seconds",{ns:"get_unit_label"})}[unit]||unit})(unit):(unit=>{const t=i18next.Z.t.bind(i18next.Z);return{"fiscal year":t("fiscal year",{ns:"get_unit_label"}),year:t("year",{ns:"get_unit_label"}),"fiscal quarter":t("fiscal quarter",{ns:"get_unit_label"}),quarter:t("quarter",{ns:"get_unit_label"}),month:t("month",{ns:"get_unit_label"}),week:t("week",{ns:"get_unit_label"}),day:t("day",{ns:"get_unit_label"}),hour:t("hour",{ns:"get_unit_label"}),minute:t("minute",{ns:"get_unit_label"}),second:t("second",{ns:"get_unit_label"}),"complete fiscal year":t("complete fiscal year",{ns:"get_unit_label"}),"complete year":t("complete year",{ns:"get_unit_label"}),"complete fiscal quarter":t("complete fiscal quarter",{ns:"get_unit_label"}),"complete quarter":t("complete quarter",{ns:"get_unit_label"}),"complete month":t("complete month",{ns:"get_unit_label"}),"complete week":t("complete week",{ns:"get_unit_label"}),"complete day":t("complete day",{ns:"get_unit_label"}),"complete hour":t("complete hour",{ns:"get_unit_label"}),"complete minute":t("complete minute",{ns:"get_unit_label"}),"complete second":t("complete second",{ns:"get_unit_label"})}[unit]||unit})(unit),describeDateTime=(date,showTime)=>{if(!date)return"Invalid Date";const{year,month,day,hour=0,minute=0}=date;let result=String(zeroPad4(year));var value;return result+=month?`/${zeroPad2(month)}`:"",result+=day?`/${zeroPad2(day)}`:"",showTime&&(result+=` ${formatAndDisplayTime({hour:(value=hour.toString(),parseInt((value=>value||"0")(value),10)),minute,meridiem:meridiemFrom24HourTime(hour)})}`),result},describeInterval=({value,unit,complete})=>{const t=i18next.Z.t.bind(i18next.Z);return t("value complete unitLabel",{ns:"describe_date",value,complete:complete?t(" complete",{ns:"describe_date"}):"",unitLabel:getUnitLabel(unit,value)})},describeTypeAndUnit=({type,unit})=>{const t=i18next.Z.t.bind(i18next.Z),thisText=t("this",{ns:"describe_date"}),nextText=t("next",{ns:"describe_date"});return t("is type unitLabel",{ns:"describe_date",type:"this"===type?thisText:nextText,unitLabel:getUnitLabel(unit)})},describe_date_beforeAfter=(item,showTime)=>{const t=i18next.Z.t.bind(i18next.Z),{type,range,date,fromnow}=item,prefix=t("after"===type?"is on or after":"is before",{ns:"describe_date"});if("absolute"===range)return t("absolute prefix dateTime",{ns:"describe_date",prefix,dateTime:describeDateTime(date,showTime)});const timePassed=t(fromnow?"from now":"ago",{ns:"describe_date"});return"now"===item.unit?t("prefix now",{ns:"describe_date",prefix}):t("prefix interval timePassed",{ns:"describe_date",prefix,interval:describeInterval(item),timePassed})},describe_date_filterToStringMap={null:describeNull,notnull:()=>i18next.Z.t.bind(i18next.Z)("is not null",{ns:"describe_date"}),pastAgo:item=>i18next.Z.t.bind(i18next.Z)("is interval ago",{ns:"describe_date",interval:describeInterval(item)}),past:item=>i18next.Z.t.bind(i18next.Z)("is in the last",{ns:"describe_date",describeInterval:describeInterval(item)}),this:describeTypeAndUnit,next:describeTypeAndUnit,last:({unit})=>i18next.Z.t.bind(i18next.Z)("is previous unitLabel",{ns:"describe_date",unitLabel:getUnitLabel(unit)}),year:({year})=>i18next.Z.t.bind(i18next.Z)("is in the year year",{ns:"describe_date",year}),month:({month,year})=>i18next.Z.t.bind(i18next.Z)("is in month year",{ns:"describe_date",month:(0,get_months.w)()[parseInt(month,10)-1],year}),before:describe_date_beforeAfter,after:describe_date_beforeAfter,range:({start,end},showTime)=>i18next.Z.t.bind(i18next.Z)("is from dateTimeStart until dateTimeEnd",{ns:"describe_date",dateTimeStart:describeDateTime(start,showTime),dateTimeEnd:describeDateTime(end,showTime)}),thisRange:({startInterval,endInterval})=>i18next.Z.t.bind(i18next.Z)("this startInterval to endInterval",{ns:"describe_date",startInterval,endInterval}),on:({date},showTime)=>i18next.Z.t.bind(i18next.Z)("is on dateTime",{ns:"describe_date",dateTime:describeDateTime(date,showTime&&(0,date_conversions.Y8)(date))}),relative:({startInterval,endInterval,intervalType})=>{const t=i18next.Z.t.bind(i18next.Z),agoText=t("ago",{ns:"describe_date"}),fromNowText=t("from now",{ns:"describe_date"});return t("is intervalStart intervalType for intervalEnd",{ns:"describe_date",intervalStart:describeInterval(startInterval),intervalType:"ago"===intervalType?agoText:fromNowText,intervalEnd:describeInterval(endInterval)})},anyvalue:()=>i18next.Z.t.bind(i18next.Z)("is any time",{ns:"describe_date"}),user_attribute:describeUserAttribute,day:({day})=>i18next.Z.t.bind(i18next.Z)("is day",{ns:"describe_date",day})},getDistanceUnitLabels=unit=>{const t=i18next.Z.t.bind(i18next.Z);switch(unit){case"feet":return t("feet",{ns:"get_distance_unit_labels"});case"kilometers":return t("kilometers",{ns:"get_distance_unit_labels"});case"meters":return t("meters",{ns:"get_distance_unit_labels"});case"miles":return t("miles",{ns:"get_distance_unit_labels"})}return""},describeLat=lat=>{const t=i18next.Z.t.bind(i18next.Z),latAbs=Math.abs(lat).toFixed(1),textNorth=t("lat degrees north",{ns:"describe_location",lat:latAbs}),textSouth=t("lat degrees south",{ns:"describe_location",lat:latAbs});return lat>0?textNorth:textSouth},describeLon=lon=>{const t=i18next.Z.t.bind(i18next.Z),lonAbs=Math.abs(lon).toFixed(1),textEast=t("lon degrees east",{ns:"describe_location",lon:lonAbs}),textWest=t("lon degrees west",{ns:"describe_location",lon:lonAbs});return lon>0?textEast:textWest},describe_location_filterToStringMap={box:({lon,lat,lon1,lat1})=>{const t=i18next.Z.t.bind(i18next.Z);return lon&&lat&&lon1&&lat1?t("coords1 to coords2",{coords1:`${describeLat(lat)}, ${describeLon(lon)}`,coords2:`${describeLat(lat1)}, ${describeLon(lon1)}`,ns:"describe_location"}):""},circle:({distance,unit,lat,lon})=>{const t=i18next.Z.t.bind(i18next.Z);return distance&&unit&&lat&&lon?t("distance unit from lat, lon",{ns:"describe_location",distance,unit:getDistanceUnitLabels(unit),lat,lon}):""},location:({lat,lon})=>lat&&lon?`${lat}, ${lon}`:"",anyvalue:()=>i18next.Z.t.bind(i18next.Z)("is anywhere",{ns:"describe_location"}),null:()=>i18next.Z.t.bind(i18next.Z)("is null",{ns:"describe_location"}),notnull:()=>i18next.Z.t.bind(i18next.Z)("is not null",{ns:"describe_location"}),user_attribute:describeUserAttribute},location_to_string_filterToStringMap={location:({lat,lon})=>lat&&lon?`${lat}, ${lon}`:"",circle:({distance,unit,lat,lon})=>distance&&unit&&lat&&lon?`${distance} ${unit} from ${lat}, ${lon}`:"",box:({lon,lat,lon1,lat1})=>lon&&lat&&lon1&&lat1?`inside box from ${lat}, ${lon} to ${lat1}, ${lon1}`:"",anyvalue:()=>"",null:()=>"null",notnull:()=>"-null",user_attribute:userAttributeToString},locationToExpression=item=>(0,location_to_string_filterToStringMap[item.type])?.(item)||"",describeIsAnyValue=()=>{const t=i18next.Z.t.bind(i18next.Z);return describeIsItem(!0,t("any value",{ns:"describe_is_any_value"}))};__webpack_require__("../../node_modules/core-js/modules/esnext.async-iterator.reduce.js"),__webpack_require__("../../node_modules/core-js/modules/esnext.iterator.reduce.js");const joinOr=values=>{const t=i18next.Z.t.bind(i18next.Z);return values.reduce(((acc,value)=>""===acc?value:t("a or b",{ns:"join_or",a:acc,b:value})),"")},describeSingleValue=({is,type,value})=>describeIsItem(is,`${type} ${value&&value.length?value[0]:""}`),describe_number_filterToStringMap={null:describeNull,between:({bounds,low,high,is})=>{if(bounds){const t=i18next.Z.t.bind(i18next.Z),range=`${bounds[0]}${low}, ${high}${bounds[1]}`,isInRangeText=t("is in range range",{ns:"describe_number",range}),isNotInRangeText=t("is not in range range",{ns:"describe_number",range});return is?isInRangeText:isNotInRangeText}return""},"=":({is,value})=>value&&value.length?describeIsItem(is,joinOr(value)):describeIsAnyValue(),">":describeSingleValue,">=":describeSingleValue,"<":describeSingleValue,"<=":describeSingleValue,user_attribute:describeUserAttribute};__webpack_require__("../../node_modules/core-js/modules/esnext.async-iterator.every.js"),__webpack_require__("../../node_modules/core-js/modules/esnext.iterator.every.js");var NumberTypes,flow=__webpack_require__("../../node_modules/lodash/fp/flow.js"),flow_default=__webpack_require__.n(flow),isEmpty=__webpack_require__("../../node_modules/lodash/isEmpty.js"),isEmpty_default=__webpack_require__.n(isEmpty),partition=__webpack_require__("../../node_modules/lodash/partition.js"),partition_default=__webpack_require__.n(partition);!function(NumberTypes){NumberTypes.EQUAL="=",NumberTypes.GT=">",NumberTypes.GTE=">=",NumberTypes.LT="<",NumberTypes.LTE="<=",NumberTypes.LT_GT="<>",NumberTypes.NOT_EQUAL="!=",NumberTypes.NULL="null",NumberTypes.BETWEEN="between"}(NumberTypes||(NumberTypes={}));const isNullUndefinedOrEmpty=value=>null==value||""===value,valueToString=({is,type,value})=>value?.map((v=>`${isToString(is)}${"="===type?"":type}${v}`)).join(",")||"",isToString=(is=!0,yes="",no="not ")=>`${is?yes:no}`,number_to_string_filterToStringMap={null:({is})=>`${isToString(is)}null`,between:({bounds,low,high,is})=>!bounds||isNullUndefinedOrEmpty(low)&&isNullUndefinedOrEmpty(high)?"":`${isToString(is)}${bounds[0]}${defaultTo_default()(low,"")},${defaultTo_default()(high,"")}${bounds[1]}`,user_attribute:userAttributeToString},serializeNumberNode=item=>(number_to_string_filterToStringMap[item.type]||valueToString)?.(item)||"",numberToString=flow_default()(tree_to_list.i,(items=>items.filter((({type,value})=>!(["=",">","<",">=","<="].indexOf(type)>-1&&isEmpty_default()(value))))),(list=>{const[orClauses,andClauses]=partition_default()(list,(item=>item.is));return 1===andClauses.length&&!(andClauses[0].type===NumberTypes.EQUAL&&andClauses[0].value?.length>1)&&orClauses.length>=1&&orClauses.every((item=>"="===item.type))?[...orClauses,...andClauses,andClauses[0]]:list}),(items=>items.map(serializeNumberNode).filter(String).join(","))),addQuotes=value=>/^-|['",]/.test(value)?`"${value}"`:value,describeMultiValue=value=>value&&joinOr(value.map(addQuotes)),describe_string_filterToStringMap={blank:({is})=>{const t=i18next.Z.t.bind(i18next.Z);return describeIsItem(is,t("blank",{ns:"describe_string"}))},null:describeNull,match:({is,value})=>value&&value.length?describeIsItem(is,describeMultiValue(value)):describeIsAnyValue(),contains:({is,value})=>{const t=i18next.Z.t.bind(i18next.Z),valueText=describeMultiValue(value),containsText=t("contains value",{ns:"describe_string",value:valueText}),doesntContainText=t("does not contain value",{ns:"describe_string",value:valueText});return is?containsText:doesntContainText},startsWith:({is,value})=>{const t=i18next.Z.t.bind(i18next.Z),valueText=describeMultiValue(value),startsWithText=t("starts with value",{ns:"describe_string",value:valueText}),doesntStartWithText=t("does not start with value",{ns:"describe_string",value:valueText});return is?startsWithText:doesntStartWithText},endsWith:({is,value})=>{const t=i18next.Z.t.bind(i18next.Z),valueText=describeMultiValue(value),endsWithText=t("ends with value",{ns:"describe_string",value:valueText}),doesntEndWithText=t("does not end with value",{ns:"describe_string",value:valueText});return is?endsWithText:doesntEndWithText},user_attribute:describeUserAttribute,anyvalue:describeIsAnyValue},escapeLeadingAndTrailingWhitespaces=(value,doubleEscapeLastEscapedTrailingSpace=!0)=>{let str=value.replace(/^([ ]*)(.*?)([ ]*)$/g,((_,g1,g2,g3)=>(g1?g1.replace(/[ ]/g,"^ "):"")+(g2||"")+(g3?g3.replace(/[ ]/g,"^ "):"")));return str.endsWith("^ ")&&!str.includes("'")&&!str.includes('"')&&doubleEscapeLastEscapedTrailingSpace&&(str+="^ "),str},escapeWithCaret=value=>value.replace(/[%^_,]/g,(c=>`^${c}`)),quoteFilter=filter=>(null==filter&&(filter=""),"string"!=typeof filter||!/^-|['",%_^]/.test(filter)&&"null"!==filter.toLowerCase()&&"empty"!==filter.toLowerCase()?filter:`"${filter.replace(/"/g,'\\"')}"`),escapeWithDoubleLastEscape=v=>escapeLeadingAndTrailingWhitespaces(v),escapeWithoutDoubleLastEscape=v=>escapeLeadingAndTrailingWhitespaces(v,!1),multiValueToString=(values,toString)=>values.map(toString).join(","),string_filter_to_string_filterToStringMap={startsWith:({value,is})=>multiValueToString(value.map(escapeWithCaret).map(escapeWithoutDoubleLastEscape),(token=>`${is_item_to_string(is,"","-")+String(token)}%`)),endsWith:({value,is})=>multiValueToString(value.map(escapeWithCaret).map(escapeWithDoubleLastEscape),(token=>`${is_item_to_string(is,"","-")}%${String(token)}`)),contains:({value,is})=>multiValueToString(value.map(escapeWithCaret).map(escapeWithoutDoubleLastEscape),(token=>`${is_item_to_string(is,"","-")}%${String(token)}%`)),match:({value,is})=>is_item_to_string(is,"","-")+value.map(quoteFilter).map(escapeWithDoubleLastEscape).join(`,${is_item_to_string(is,"","-")}`),blank:({is})=>`${is_item_to_string(is,"","-")}EMPTY`,null:({is})=>`${is_item_to_string(is,"","-")}NULL`,user_attribute:userAttributeToString,anyvalue:()=>"",other:({value,is})=>multiValueToString(value,(token=>`${is_item_to_string(is,"","-")}${String(token)}`))},stringToExpression=item=>(0,string_filter_to_string_filterToStringMap[item.type])?.(item)||"",itemIsNotEmpty=({type,value})=>!(["match","contains","startsWith","endsWith","other"].indexOf(type)>-1&&isEmpty_default()(value));var keyBy=__webpack_require__("../../node_modules/lodash/keyBy.js"),keyBy_default=__webpack_require__.n(keyBy);const escapeParameterValue=value=>value.replace(/([\^_%,"']|^-)/g,"^$1"),describe_tier_filterToStringMap={match:({is,value},_,field)=>value&&value.length?describeIsItem(is,((values,field)=>{if(values){if(field?.parameter&&field?.has_allowed_values){const valueMap=keyBy_default()(field.enumerations,"value");return joinOr(values.map((value=>{const escapedValue=escapeParameterValue(value);return valueMap[escapedValue]?.label||value})))}return joinOr(values.map(addQuotes))}return""})(value,field)):describeIsAnyValue(),user_attribute:describeUserAttribute,anyvalue:describeIsAnyValue},tier_filter_to_string_filterToStringMap={anyvalue:()=>"",match:({value,is},_,field)=>is_item_to_string(is,"","-")+value.map((val=>field?.has_allowed_values&&field?.parameter?escapeParameterValue(val):quoteFilter(val))).join(`,${is_item_to_string(is,"","-")}`),user_attribute:userAttributeToString},tier_filter_to_string_listToExpression=(type,field)=>items=>items.map(((type,field)=>item=>(0,tier_filter_to_string_filterToStringMap[item.type])?.(item,type,field)||"")(type,field)).join(",");var cloneDeep=__webpack_require__("../../node_modules/lodash/cloneDeep.js"),cloneDeep_default=__webpack_require__.n(cloneDeep),inorder_traversal=__webpack_require__("../filter-expressions/src/utils/tree/inorder_traversal.ts"),remove_node=__webpack_require__("../filter-expressions/src/utils/tree/remove_node.ts"),union=__webpack_require__("../../node_modules/lodash/union.js"),union_default=__webpack_require__.n(union);const mergeNodes=(left={},right={})=>({...left,type:left.type,value:union_default()(left.value,right.value),is:left.is&&right.is}),canMergeLeftNodes=({left,right},compareType,allowDifferentIsValue)=>left&&right&&right.left&&left.type===right.left.type&&left.type===compareType&&(left.is===right.left.is||allowDifferentIsValue),mergeNodesWithSameType=(root,compareType,allowDifferentIsValue=!1)=>{let node=root;for(;canMergeLeftNodes(node,compareType,allowDifferentIsValue);){const{left,right,...rest}=node,newLeft=mergeNodes(left,right?.left),newRight=right?.right;node={...rest,left:newLeft,right:newRight}}return(({left,right},compareType,allowDifferentIsValue)=>left&&right&&left.type===right.type&&left.type===compareType&&(left.is===right.is||allowDifferentIsValue))(node,compareType,allowDifferentIsValue)&&(node=mergeNodes(node.left,node.right)),node},mergeMultiValueNodes=(root,type,mergeDifferentIsValue=!1)=>{const workingRoot=mergeNodesWithSameType(root,type,mergeDifferentIsValue);let pointer=workingRoot;for(;pointer.right;)pointer.right=mergeNodesWithSameType(pointer.right,type,mergeDifferentIsValue),pointer=pointer.right;return workingRoot};var apply_id_to_ast=__webpack_require__("../filter-expressions/src/utils/transform/utils/apply_id_to_ast.ts");const stringTransform=root=>["match","contains","startsWith","endsWith"].reduce(((ast,type)=>mergeMultiValueNodes(ast,type)),root),dateGrammarOptions={grammar:dateGrammar,toString:(root,type)=>{return treeToString(root,(showTime=(0,is_date_time.v)(type),item=>(0,filterToStringMap[item.type])?.(item,showTime)||""));var showTime},describe:(item,expressionType)=>defaultTo_default()(describe_date_filterToStringMap[item.type],(()=>""))(item,(0,is_date_time.v)(expressionType)),anyvalue:anyValue,subTypes:["null","anyvalue","notnull","past","pastAgo","this","next","last","year","month","before","after","range","thisRange","on","relative","user_attribute","day"]},grammarsMap={date:dateGrammarOptions,date_time:dateGrammarOptions,number:{grammar:numberGrammar,toString:numberToString,transform:root=>{const countOfNotNodes=(root=>{let count=0;return(0,inorder_traversal.G)(root,(node=>{!1===node.is&&(count+=1)})),count})(root),mergeNodesWithDifferentIsValue=1===countOfNotNodes,mergedRoot=mergeMultiValueNodes(root,NumberTypes.EQUAL,mergeNodesWithDifferentIsValue);return 2===countOfNotNodes?(root=>{const workingRoot=cloneDeep_default()((0,apply_id_to_ast.Z)(root)),andClauses=(0,tree_to_list.i)(workingRoot).filter((item=>!1===item.is));return 2===andClauses.length&&serializeNumberNode(andClauses[0])===serializeNumberNode(andClauses[1])?(0,remove_node.Z)(workingRoot,andClauses[1].id)||{}:workingRoot})(mergedRoot):mergedRoot},describe:item=>defaultTo_default()(describe_number_filterToStringMap[item.type],(()=>""))(item),anyvalue:{id:1,type:"=",value:[],is:!0},subTypes:["=",">","<",">=","<=","between","null","user_attribute"]},string:{grammar:stringGrammar,toString:root=>treeToString(root,stringToExpression,itemIsNotEmpty),transform:stringTransform,describe:item=>defaultTo_default()(describe_string_filterToStringMap[item.type],(()=>""))(item),anyvalue:anyStringItem,subTypes:["null","contains","match","startsWith","endsWith","blank","user_attribute"]},tier:{grammar:tierGrammar,toString:(root,type,field)=>flow_default()(tree_to_list.i,tier_filter_to_string_listToExpression(type,field))(root),transform:stringTransform,describe:(item,filterType,field)=>defaultTo_default()(describe_tier_filterToStringMap[item.type],(()=>""))(item,filterType,field),anyvalue:anyStringItem,subTypes:["anyvalue","match","user_attribute"]},location:{grammar:locationGrammar,toString:root=>treeToString(root,locationToExpression),describe:item=>defaultTo_default()(describe_location_filterToStringMap[item.type],(()=>""))(item),anyvalue:anyValue,subTypes:["location","circle","box","anyvalue","null","notnull","user_attribute"]}},typeToGrammar=type=>grammarsMap[type]||{}}}]);