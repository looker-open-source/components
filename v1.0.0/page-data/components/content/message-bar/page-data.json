{"componentChunkName":"component---src-layout-documentation-tsx","path":"/components/content/message-bar/","result":{"data":{"site":{"siteMetadata":{"title":"Looker UI Components"}},"mdx":{"id":"df27d7b4-0916-5a9b-b245-c527d647ec22","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"MessageBar\",\n  \"storybook\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<MessageBar />\"), \" component is used to alert the user with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"warn\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"critical\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inform\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"positive\"), \" messages, settable via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"intent\"), \" property. If no intent is set, it will fall back to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inform\"), \" by default.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<SpaceVertical gap=\\\"xsmall\\\">\\n  <MessageBar intent=\\\"inform\\\">Inform (default)</MessageBar>\\n  <MessageBar intent=\\\"warn\\\">Warning</MessageBar>\\n  <MessageBar intent=\\\"positive\\\">Positive</MessageBar>\\n  <MessageBar intent=\\\"critical\\\">Critical</MessageBar>\\n</SpaceVertical>\\n\")), mdx(\"h2\", null, \"Customizing the action buttons\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MessageBar\"), \" allows you to pass your own custom actions in place of the standard dismiss button. There are two such props, that are flexible in their use and output. In addition, there are two more props for tying into action clicks:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"primaryAction\"), \": string or ReactElement\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onPrimaryClick\"), \": () => void\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"secondaryAction\"), \": string or ReactElement\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onSecondaryClick\"), \": () => void\")), mdx(\"h3\", null, \"Non-clearable MessageBar\"), mdx(\"p\", null, \"If you don't want the MessageBar to be clearable, you can hide all action buttons with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noActions\"), \" prop.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<MessageBar noActions>I can't be closed</MessageBar>\\n\")), mdx(\"h3\", null, \"Custom string labels\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MessageBar\"), \" allows you to pass your own custom actions in place of the standard dismiss button. It accepts two different props: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"primaryButton\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"secondaryButton\"), \" which will both accept a custom JSX element.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<MessageBar\\n  primaryAction=\\\"Primary Action\\\"\\n  onPrimaryClick={() => alert('Primary Action')}\\n  secondaryAction=\\\"Secondary Action\\\"\\n  onSecondaryClick={() => alert('Secondary Action')}\\n>\\n  Render some custom action labels!\\n</MessageBar>\\n\")), mdx(\"h3\", null, \"Rendering custom components\"), mdx(\"p\", null, \"This is not the recommended happy path for using MessageBar, but it is available if you run into an edge case that is not supported by customizing the string label and click callbacks. Just keep in mind that if you decide to render custom components you will be responsible for allowing the MessageBar to be cleared.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \";() => {\\n  const [visible, setVisible] = useState(true)\\n  const handlePrimaryClick = () => {\\n    alert('Primary Action')\\n    setVisible(false)\\n  }\\n  const handleSecondaryClick = () => {\\n    alert('Secondary Action')\\n    setVisible(false)\\n  }\\n  return (\\n    <MessageBar\\n      primaryAction={\\n        <IconButton\\n          icon={<Favorite />}\\n          label=\\\"Add to Favorites\\\"\\n          onClick={handlePrimaryClick}\\n          color=\\\"key\\\"\\n        />\\n      }\\n      secondaryAction={\\n        <IconButton\\n          onClick={handleSecondaryClick}\\n          color=\\\"neutral\\\"\\n          icon={<Settings />}\\n          label=\\\"Settings\\\"\\n          color=\\\"neutral\\\"\\n        />\\n      }\\n      visible={visible}\\n    >\\n      Render some custom action components!\\n    </MessageBar>\\n  )\\n}\\n\")), mdx(\"h2\", null, \"Controlled Component Pattern\"), mdx(\"p\", null, \"To control MessageBar renderin externally, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onPrimaryAction\"), \" in conjunction with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"visible\"), \" boolean prop. This can be useful if you wish to provide an Undo or other complex workflows.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \";() => {\\n  const { value, setOff, setOn } = useToggle(true)\\n  return (\\n    <>\\n      <MessageBar intent=\\\"warn\\\" onPrimaryClick={setOff} visible={value}>\\n        I can be closed and reopened\\n      </MessageBar>\\n      {!value && (\\n        <ButtonOutline m=\\\"medium\\\" onClick={setOn}>\\n          Show MessageBar\\n        </ButtonOutline>\\n      )}\\n    </>\\n  )\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"github":null,"status":null,"storybook":true,"storybookPath":null,"title":"MessageBar"}}},"pageContext":{"id":"df27d7b4-0916-5a9b-b245-c527d647ec22"}},"staticQueryHashes":["1992130076","2337259409","4275213719","4275213719"]}